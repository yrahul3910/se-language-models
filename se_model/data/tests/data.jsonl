[3758880, {"text_blocks": ["> **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.\n>\n> Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]\nSource: [Formatting byte size to human readable format | Programming.Guide][2]\n# SI (1 k = 1,000)", "# Binary (1 Ki = 1,024)", "# Example output:", "  [1]: https://programming.guide/worlds-most-copied-so-snippet.html\n  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html"], "comments": ["The only thing I don't like about it is that 1.0 KB could be displayed prettier as 1 KB. (Which is why I use DecimalFormat in my answer)", "I prefer 1.0 KB. Then it's clear how many significant figures the output entails. (This also seems to be the behavior of for instance the `du` command in Linux.)", "I think every one should note that in your project customer want see values in base 2 (devided by 1024) but with common prefix. Not KiB, MiB, GiB etc. Use KB, MB, GB, TB for it.", "@Mazyod For iOS developers, you can use [NSByteCountFormatter](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSByteCountFormatter_Class/index.html). \n\nFor example (in swift):\n\n`let bytes = 110592\nNSByteCountFormatter.stringFromByteCount(Int64(bytes), countStyle: NSByteCountFormatterCountStyle.File)`\nwould produce \"111 KB\"", "The code is short, but `charAt`, `?` operator and `String.format` to get the unit isn't human readable ...", "@Borys Using \"KB\" to mean \"1024 bytes\" is wrong.  Don't do that.", "@endolith that's an example of prescriptivism vs descriptivism", "@endolith not denying it's \"wrong\" according to the IEC standard. However, its usage is rare compared to the popular usage of MB to mean 1024*1024 bytes. \"MB\" is used by Windows, for example. Using MiB, although correct (according to IEC), may confuse readers who are unfamiliar with it. It all depends on who your audience is. Anyway, let's not let this detract from my main criticism, which is that this method can produce incorrect results.", "Readers will learn it. Better something they are unfamiliar with and can learn it than having something wrong. Writing KB a user who is familiar with it will expect 1000 and a user who is unfamiliar will expect 1024.", "@KlitosKyriacou \"But we know what it means so it's not a big problem\" -- I have lost count of the number of times I've spoken with people who think they knew which unit they meant but when questioned they don't have a clue and/or disagree with the person they thought they were in agreement with. Use SI units for base 10 and IEC for base 2 and the world will be a better place.", "**Answer rewritten entirely. Many of the above comments are obsolete.**", "Wow :D In your article (really fun read BTW) you've written: \"After ironing out all corner cases the code is even less readable than the original version. Personally I would not copy this snippet into production code.\" I don't see how is the new snippet more readable :D What are the other reasons that back up this code over the previous one? Performance? Being concise and still without rounding bugs?", "@matvs Ok, I admit that I might have golfed the new version a bit too far. It's not super readable, but it's fairly clear that it's nothing but an unrolled loop at this point.\n\nFirst of all, this version is _correct_, and I'd argue that it's far less complicated than the previous version. For example, the really funky floating point stuff is gone. The log/pow stuff (which was fun to write but not fun to read) is gone. The si/binary flag (which adds to the complexity but that you typically never care about) is gone.\n\nAs for performance, I have no idea :-) Someone should profile it.", "@slonik, no, kilo is abbreviated with lower-case k. This is the [official publication](https://www.nist.gov/pml/special-publication-330/sp-330-section-3#table7) from nist.gov", "@KlitosKyriacou \"But officer, I *wasn't* speeding!  By *my* definition of 'kilometer', I was only going 5 km/h.\"", "@endolith I think a better analogy might be the definition of calories. When a can of diet drink says it contains \"Less than 1 calorie\", it uses the colloquial and common definition of \"calorie\" - it really means kilocalorie. But we know what it means so it's not a big problem.", "@KlitosKyriacou But is that 1000 calories or 1024 calories?  Units of measurement *are* prescriptive; they wouldn't work otherwise.  \"kilo-\" has meant \"1000\" for thousands of years.  Using it to refer to 1024 of something is wrong."]}]
[326440, {"text_blocks": ["Read all text from a file\n-------------------------\nJava 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:", "For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:", "Read lines of text from a file\n------------------------------\nJava 7 added a [convenience method to read a file as lines of text,][2] represented as a `List<String>`. This approach is \"lossy\" because the line separators are stripped from the end of each line.", "Java 8 added the [`Files.lines()`][3] method to produce a `Stream<String>`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.", "This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.\nIf you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.\nMemory utilization\n------------------\nThe first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.\nThe second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.\nFor reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, \"large\" depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream<String>` is one way to do this, if your input \"records\" happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)\nCharacter encoding\n------------------\nOne thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.\nThe [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:", "The platform default is available from [the `Charset` class][8] itself:", "---\nNote: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the \"edited\" link on this answer.\n  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)\n  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29\n  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-\n  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html\n  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--\n  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--\n  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html\n  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29"], "comments": ["@Sam A `StringBuffer` can\u2019t hold that much either. The limitation is that the size is stored as an `int`. I think the most efficient alternative for that size would be `Files.readAllLines()`. I haven\u2019t benchmarked it though.", "@Sam don\u2019t use A when you want B. The fact that `Files.readString` is the most efficient way to read a file *into a single string* doesn\u2019t imply that using it when you actually want something entirely different, like a *list of lines*, was a good idea. As erickson said, there\u2019s `Files.readAllLines\u200b` doing the job.", "Technically speaking, it's O(n) in time and space. Qualitatively, due the immutability requirement of Strings, it's pretty hard on memory; temporarily there are two copies of the char data in memory, plus the room for the encoded bytes. Assuming some single-byte encoding, it will (temporarily) require 5 bytes of memory for each character in the file. Since the question asks specifically for a String, that's what I show, but if you can work with the CharBuffer returned by \"decode\", the memory requirement is much less. Time-wise, I don't think you'll find anything faster in the core Java libs.", "Possible typo? NIO has a Charset (not CharSet) class called java.nio.charset.Charset. Is this what CharSet should have been?", "Note : after exercising a bit that code, I found out that you can't reliably delete the file right after reading it with this method, which may be a non issue in some case, but not mine.\nMay it be in relation with this issue : http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4715154 ?\n\nI finally went with the proposition of Jon Skeet which doesn't suffer from this bug.\n\nAnyways, I just wanted to give the info, for other people, just in case...", "@S\u00e9bastien Nussbaumer: I also bumped on this problem. Amazing that the bug has been marked \"Will Not Fix\". This essentially means that `FileChannel#map` is, in general, unusable.", "@S\u00e9bastien Nussbaumer: The bug has been deleted from the Oracle / Sun Bug Database: \"This bug is not available.\" Google cached the site at http://webcache.googleusercontent.com/search?q=cache:bugs.sun.com/bugdatabase/view_bug.do%3Fbug_id%3D4715154", "@smilepleeeaz What you describe makes no sense. EXE files are not text. And they have a well-defined structure. First you are destroying the content of the file by decoding it as text, then you are destroying the structure by appending text to it. How could this fail to corrupt the EXE?", "@yannbane If you are sure that the file will always be encoded with the platform's default character set, yes, you could do that. If there's a mismatch, then you'll care about encoding.", "As of Java 8, the charset can be omitted to default to using UTF-8. Thus reading all lines becomes `Files.readAllLines(Paths.get(\"/your/path/to/file\"));`", "I tried using the readFile method of this answer but I can't find where the `Files` class is located.  I'm using JDK 1.7.0_79", "@JpajiRajnish [`java.nio.file.Files`](http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html)", "@Sam that comment was from 2009; it does not consider APIs that were created at a later time. Nowadays, there is no reason not to use the newer `Files.readString`. It\u2019s the fastest *and* least memory consuming method. In the reference implementation, it uses tricks that other libraries could not use and avoids the redundant-copies problem. In the best case, there is only one copy of the character data in memory at any time (for iso-latin-1 or all-ascii strings, the I/O buffer will be the resulting string\u2019s backing array without any copy operation).", "@Sam If reading lines works for you, you should consider the final state you want for those strings. The use cases that come to my mind for multi-gigabyte files in memory are caches; these are likely to need some sort of index, and it seems less likely that you'll have a direct use for `List<String>`. So instead of loading the list, and then converting each string to another object, and then adding each of those to some other data structure, you should read one line, convert it to the necessary type, and add it to the structure. Then do the next. Use stream-wise processing.", "@Sam If your input is one line per record, an actual `Stream` would work, but I was talking more generally. In your case, I think the most idiomatic approach would be to create a `BufferedReader`, and, in a loop, read the five lines representing each record/object in each iteration. If you can do all the necessary processing for that item inside the loop, you won't need to keep a reference, and memory usage will be constant. If you need to keep *all* the objects together after reading the file, you can add them to a suitable collection in the loop."]}]
